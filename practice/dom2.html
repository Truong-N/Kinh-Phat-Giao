
<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Document</title>
   </head>
   <style>
      * {
      cursor: pointer;
      }
      .viet {
      color: red;
      }
      img { width: 75%;}
      
   </style>
   <body>
      <div>
         <div>
            <button id="stop">Stop!</button>
            <button id="speak">Speak</button>
         </div>
         <label><input type="checkbox" id="readeng" name="pencil" >read English only</label><br>
         <a href="./">Prev</a>
         <a href="./index.html">Index</a>
         <a href="./">Next</a>
      </div>
      <div style="font-size: larger;" class="read"></div>
      <div class="vietEng">
      <p><span class="viet"> Các nút DOM tồn tại như thế nào so với nhau trong cây DOM? </span><span class="eng"> How Do DOM Nodes Exist Relative to Each Other in the DOM Tree? </span></p>
<p><span class="viet"> Hãy cùng tìm hiểu về các nút DOM và mối quan hệ của chúng trong cây DOM. </span><span class="eng"> Let's learn about DOM nodes and their relationships in the DOM tree. </span></p>
<p><span class="viet"> Giống như một cây thật có các nhánh lớn và nhỏ được kết nối theo cấu trúc phân cấp, </span><span class="eng"> Just as a real tree has large and small branches connected in a hierarchical structure, </span><span class="viet"> các nút DOM cũng có mối quan hệ trực tiếp và gián tiếp với nhau. </span><span class="eng"> DOM nodes also have direct and indirect relationships with one another. </span><span class="viet"> Chúng ta sẽ sử dụng ví dụ này để minh họa các mối quan hệ đó: </span><span class="eng"> We will use this example to illustrate these relationships: </span></p>
<pre>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;DOM Tree Example&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Heading 1&lt;/h1&gt;
    &lt;p&gt;Paragraph 1&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;List item 1&lt;/li&gt;
      &lt;li&gt;List item 2&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p><span class="viet"> Hãy bắt đầu từ trên cùng. </span><span class="eng"> Let's start at the top. </span><span class="viet"> Gốc của cây DOM là phần tử html. </span><span class="eng"> The root of the DOM tree is the html element. </span><span class="viet"> Nó là vùng chứa cấp cao nhất cho tất cả nội dung của một tài liệu HTML. </span><span class="eng"> It's the top-level container for all the content of an HTML document. </span><span class="viet"> Tất cả các nút khác là hậu duệ của nút gốc này. </span><span class="eng"> All other nodes are descendants of this root node. </span></p>
<p><span class="viet"> Sau đó, </span><span class="eng"> Then, </span><span class="viet"> bên dưới nút gốc, </span><span class="eng"> below the root node, </span><span class="viet"> chúng ta tìm thấy các nút khác trong hệ thống phân cấp. </span><span class="eng"> we find other nodes in the hierarchy. </span><span class="viet"> Nút cha là một phần tử chứa các phần tử khác. </span><span class="eng"> A parent node is an element that contains other elements. </span><span class="viet"> Nút con là một phần tử được chứa bên trong một phần tử khác. </span><span class="eng"> A child node is an element that is contained within another element. </span></p>
<p><span class="viet"> Trong ví dụ này, </span><span class="eng"> In this example, </span><span class="viet"> phần tử body là cha của phần tử paragraph trong khi phần tử paragraph là con của phần tử body. </span><span class="eng"> the body element is the parent of the paragraph element while the paragraph element is a child of the body element. </span><span class="viet"> Các phần tử này được biểu diễn dưới dạng các nút trong cây DOM với cùng các mối quan hệ. </span><span class="eng"> These elements are represented as nodes in the DOM tree with the same relationships. </span></p>
<p><span class="viet"> Giống như chúng ta có các nút cha và nút con, </span><span class="eng"> Just like we have parent nodes and child nodes, </span><span class="viet"> chúng ta cũng có các nút anh chị em. </span><span class="eng"> we also have sibling nodes. </span><span class="viet"> Các nút anh chị em là các phần tử có chung cha. </span><span class="eng"> Sibling nodes are elements that share the same parent. </span><span class="viet"> Trong ví dụ của chúng ta, </span><span class="eng"> In our example, </span><span class="viet"> hai phần tử mục danh sách có cùng một phần tử cha là danh sách không thứ tự, </span><span class="eng"> two list item elements share the same unordered list parent, </span><span class="viet"> vì vậy chúng là anh chị em ruột. </span><span class="eng"> so they are siblings. </span></p>
<p><span class="viet"> Tương tự, </span><span class="eng"> Similarly, </span><span class="viet"> các phần tử h1 và đoạn văn là anh chị em ruột vì chúng có cùng một phần tử cha là phần tử body. </span><span class="eng"> the h1 and paragraph elements are siblings because they share the same parent,,the body element. </span></p>
<p><span class="viet"> Chúng ta cũng có các mối quan hệ gián tiếp giữa các cấp độ khác nhau trong hệ thống phân cấp. </span><span class="eng"> We also have indirect relationships across different levels in the hierarchy. </span><span class="viet"> Các nút con là các phần tử được chứa bên trong một phần tử khác, </span><span class="eng"> Descendant nodes are elements that are contained within another element, </span><span class="viet"> trực tiếp hoặc gián tiếp. </span><span class="eng"> either directly or indirectly. </span><span class="viet"> Một phần tử được coi là con của một phần tử khác nếu nó có thể được truy cập bằng cách đi xuống cây DOM từ tổ tiên của nó. </span><span class="eng"> An element is considered a descendant of another one if it can be reached by going through the DOM tree downwards from its ancestor. </span></p>
<p><span class="viet"> Trong ví dụ của chúng ta, </span><span class="eng"> In our example, </span><span class="viet"> các phần tử mục danh sách li là con của phần tử body, </span><span class="eng"> the list item li elements are descendants of the body element, </span><span class="viet"> vì chúng được chứa gián tiếp bên trong nó. </span><span class="eng"> since they are indirectly contained within it. </span></p>
<p><span class="viet"> Một nút tổ tiên là một phần tử nằm ở vị trí cao hơn trong hệ thống phân cấp cây DOM so với một phần tử khác. </span><span class="eng"> An ancestor node is an element that is higher up in the DOM tree hierarchy than another element. </span><span class="viet"> Trong ví dụ của chúng ta, </span><span class="eng"> In our example, </span><span class="viet"> phần tử body là tổ tiên của các phần tử mục danh sách li. </span><span class="eng"> the body element is an ancestor of the list item li elements. </span></p>
<p><span class="viet"> Hiểu được các mối quan hệ này là điều cần thiết để thao tác và điều hướng cây DOM bằng JavaScript. </span><span class="eng"> Understanding these relationships is essential for manipulating and navigating the DOM tree using JavaScript. </span></p>
<pre>
Which of the following is the parent node of the body element?
head
html
title
document

Three &lt;li&gt; elements within the same &lt;ul&gt; element are considered:
Parent nodes.
Child nodes.
Sibling nodes.
Descendant nodes.

A &lt;p&gt; element contained directly within a &lt;div&gt; is a:
Parent node of the &lt;div&gt;.
Child node of the &lt;div&gt;.
Sibling node of the &lt;div&gt;.
Ancestor node of the &lt;div&gt;.

</pre>
      </div>
      <script>
         const readeng = document.querySelector("#readeng")
         const eng = document.querySelectorAll(".eng")
         let pre_txt = ' '
         let readEngOnly = false
         
         readeng.addEventListener("change", () => {
            readEngOnly = !readEngOnly
            
         })
         const msg = new SpeechSynthesisUtterance();
         let voice = [];
         const speakButton = document.querySelector('#speak');
         const stopButton = document.querySelector('#stop');

         
         function speakMinutes_viet(minutesArray) {
            if (minutesArray.length > 0) {

               let txt = minutesArray.shift(); // extract first item
               
               let utterance = new SpeechSynthesisUtterance(txt);
               // When the current utterance ends, speak the next one
               utterance.onend = function (event) {
               speakMinutes_eng(minutesArray); // Recursively call the function for the next item
               };

               // Handle potential errors
               utterance.onerror = function (event) {
                  console.error('Speech synthesis error: ' + event.error);
               };
               utterance.lang = 'vi-VN'
               let txt1 = '<span class="eng"> '+minutesArray[0].trim()+' </span>'
               let l_txt = '<span class="viet"> '+txt.trim()+' </span>'
               document.querySelector(".vietEng").innerHTML = document.querySelector(".vietEng").innerHTML.replace(l_txt, "")
               document.querySelector(".vietEng").innerHTML = document.querySelector(".vietEng").innerHTML.replace(txt1, "")
               document.querySelector(".read").innerHTML = "<h2><span class='viet'>"+txt+"</span><br>"+txt1+"</h2>"
               if( readEngOnly){
                  utterance.text = ' '
               }
               speechSynthesis.speak(utterance);

            }
         }
         function speakMinutes_eng(minutesArray) {
            if (minutesArray.length > 0) {

               let txt = minutesArray.shift(); // extract first item
               
               let utterance = new SpeechSynthesisUtterance(txt);
               // When the current utterance ends, speak the next one
               utterance.onend = function (event) {
               console.log('Speech ended, starting next minute.');
               speakMinutes_viet(minutesArray); // Recursively call the function for the next item
               };

               // Handle potential errors
               utterance.onerror = function (event) {
                  console.error('Speech synthesis error: ' + event.error);
               };
               utterance.lang = 'en-US'
               speechSynthesis.speak(utterance);
            }
         }
         function readEV(startOver = true) {
            speechSynthesis.cancel();
            if (startOver) {
               let arr_len = document.getElementsByClassName('eng').length;
               let eng_txt1 = '';
               let viet_txt1 = '';
               let eng_arr = document.getElementsByClassName('eng')
               let viet_arr = document.getElementsByClassName('viet')
               let combine_arr = []
               
               for (let i = 0; i < arr_len; i++) {
                  
               
                  let eng_txt =eng_arr[i].textContent;
                  let viet_txt = viet_arr[i].textContent;
                  
                  // remove vscode format
                  // split eng_txt by "\n"
                  if (viet_txt.length > 2) {
                     eng_txt_arr = eng_txt.split("\n")
                     viet_txt_arr = viet_txt.split("\n")
                     // remove extra spaces cause by vscode 
                     eng_txt_arr = eng_txt_arr.map(e => e.trim())
                     viet_txt_arr = viet_txt_arr.map(e => e.trim())
                     // convert array back into text
                     eng_txt = eng_txt_arr.join(" ")
                     viet_txt = viet_txt_arr.join(" ")
                     combine_arr.push(viet_txt)
                     combine_arr.push(eng_txt)
                  }
               }
               // console.log(eng_arr)
               speakMinutes_viet(combine_arr)
            }
         }
         speakButton.addEventListener('click', readEV);
         stopButton.addEventListener('click', readEV.bind(null, false));
      </script>
   </body>
</html>

